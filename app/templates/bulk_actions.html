{% extends "base.html" %}
{% block content %}
  <section class="hero">
    <div class="card">
      <h2>Bulk Actions</h2>
      <p class="note">Run library-wide maintenance tasks.</p>
    </div>
  </section>

  <section class="section bulk-actions-grid">
    <div class="card">
      <h3>Scan library</h3>
      <p class="note">Index files and refresh totals.</p>
      <button class="btn" type="button" data-scan>Run scan</button>
      <p class="note" id="scan-status">Idle</p>
    </div>
    <div class="card">
      <h3>Bulk tag books</h3>
      <p class="note">Search Google Books for each title and apply tags.</p>
      <button class="btn btn-outline" type="button" data-bulk-tags>Start bulk tagging</button>
    </div>
    <div class="card">
      <h3>Export books</h3>
      <p class="note">
        Download a CSV snapshot of the library. The file includes book id, title, author, and a comma-separated list
        of tags for each book.
      </p>
      <a class="btn btn-outline" href="/bulk-actions/export">Download CSV</a>
    </div>
    <div class="card">
      <h3>Import tags from CSV</h3>
      <p class="note">Upload a CSV and apply namespaced tags to books.</p>
      <button class="btn btn-outline" type="button" data-csv-import>Import tags</button>
    </div>
    <div class="card">
      <h3>Clean unused tags</h3>
      <p class="note">Remove tag entries that are no longer associated with any books.</p>
      <button class="btn btn-outline" type="button" data-clean-tags>Delete unused tags</button>
      <p class="note" id="clean-tags-status">Idle</p>
    </div>
    <div class="card">
      <h3>Clear all tags</h3>
      <p class="note">Remove every tag and clear all book-tag links.</p>
      <button class="btn btn-outline" type="button" data-clear-tags>Clear all tags</button>
      <p class="note" id="clear-tags-status">Idle</p>
    </div>
  </section>

  <div class="modal" data-bulk-tags-modal hidden>
    <div class="modal-overlay" data-bulk-close></div>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="bulkTagModalTitle">
      <div class="modal-header">
        <h3 id="bulkTagModalTitle">Bulk Tagging</h3>
        <button class="modal-close" type="button" data-bulk-close aria-label="Close bulk tagging">&times;</button>
      </div>
      <div class="modal-body">
        <p class="note" data-bulk-status>Loading books...</p>
        <div>
          <strong data-bulk-title>Title</strong>
          <div class="note" data-bulk-author></div>
        </div>
        <div class="tag-form">
          <button class="btn btn-outline btn-small" type="button" data-bulk-search>Search tags</button>
          <button class="btn btn-outline btn-small" type="button" data-bulk-skip>Skip book</button>
          <button class="btn btn-small" type="button" data-bulk-add disabled>Add tags to book</button>
          <button class="btn btn-outline btn-small" type="button" data-bulk-stop>Stop</button>
        </div>
        <div>
          <small class="note">Current tags</small>
          <div class="tag-list" data-bulk-current-tags></div>
        </div>
        <div>
          <small class="note">Proposed tags</small>
          <div class="tag-list" data-bulk-tags></div>
        </div>
        <div class="list" data-bulk-results></div>
      </div>
    </div>
  </div>
  <div
    class="modal"
    data-csv-import-modal
    data-namespaces="{{ tag_namespaces | join(',') }}"
    hidden
  >
    <div class="modal-overlay" data-csv-close></div>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="csvImportModalTitle">
      <div class="modal-header">
        <h3 id="csvImportModalTitle">Import Tags From CSV</h3>
        <button class="modal-close" type="button" data-csv-close aria-label="Close CSV import">
          &times;
        </button>
      </div>
      <div class="modal-body">
        <p class="note" data-csv-status>Select a CSV file to begin.</p>
        <div class="card" style="margin-bottom: 1rem;">
          <label class="note" for="csv-import-file">CSV file</label>
          <input id="csv-import-file" type="file" accept=".csv,text/csv" data-csv-file />
        </div>
        <div class="card" data-csv-columns hidden>
          <div style="margin-bottom: 0.75rem;">
            <label class="note" for="csv-book-id-column">Book ID column</label>
            <select id="csv-book-id-column" data-csv-book-id></select>
          </div>
          <div>
            <div class="note" style="margin-bottom: 0.25rem;">Tag columns</div>
            <div class="list" data-csv-tag-columns></div>
            <small class="note">
              Tags are created as <code>Header:Cell</code>. Cells can contain comma-separated values.
            </small>
          </div>
        </div>
        <div class="tag-form" style="margin-top: 1rem;">
          <button class="btn btn-outline btn-small" type="button" data-csv-validate>Next</button>
          <button class="btn btn-small" type="button" data-csv-import-submit disabled>Import tags</button>
        </div>
        <p class="note" data-csv-validation></p>
      </div>
    </div>
  </div>
{% endblock %}
{% block scripts %}
  <script>
    const scanButton = document.querySelector("[data-scan]");
    const scanStatus = document.getElementById("scan-status");

    if (scanButton && scanStatus) {
      scanButton.addEventListener("click", async () => {
        scanButton.disabled = true;
        scanStatus.textContent = "Scanning...";
        try {
          const response = await fetch("/scan", { method: "POST" });
          if (!response.ok) {
            throw new Error(`Scan failed: ${response.status}`);
          }
          const result = await response.json();
          scanStatus.textContent = `Indexed ${result.indexed} files at ${result.scanned_at}`;
        } catch (error) {
          scanStatus.textContent = "Scan failed. Check server logs.";
        } finally {
          scanButton.disabled = false;
        }
      });
    }

    const bulkTagsButton = document.querySelector("[data-bulk-tags]");
    const bulkModal = document.querySelector("[data-bulk-tags-modal]");
    const bulkCloseButtons = bulkModal ? bulkModal.querySelectorAll("[data-bulk-close]") : [];
    const bulkStopButton = bulkModal ? bulkModal.querySelector("[data-bulk-stop]") : null;
    const bulkStatus = bulkModal ? bulkModal.querySelector("[data-bulk-status]") : null;
    const bulkTitle = bulkModal ? bulkModal.querySelector("[data-bulk-title]") : null;
    const bulkAuthor = bulkModal ? bulkModal.querySelector("[data-bulk-author]") : null;
    const bulkCurrentTags = bulkModal ? bulkModal.querySelector("[data-bulk-current-tags]") : null;
    const bulkResults = bulkModal ? bulkModal.querySelector("[data-bulk-results]") : null;
    const bulkTagsPreview = bulkModal ? bulkModal.querySelector("[data-bulk-tags]") : null;
    const bulkSearchButton = bulkModal ? bulkModal.querySelector("[data-bulk-search]") : null;
    const bulkSkipButton = bulkModal ? bulkModal.querySelector("[data-bulk-skip]") : null;
    const bulkAddButton = bulkModal ? bulkModal.querySelector("[data-bulk-add]") : null;
    const cleanTagsButton = document.querySelector("[data-clean-tags]");
    const cleanTagsStatus = document.getElementById("clean-tags-status");
    const clearTagsButton = document.querySelector("[data-clear-tags]");
    const clearTagsStatus = document.getElementById("clear-tags-status");
    const csvImportButton = document.querySelector("[data-csv-import]");
    const csvModal = document.querySelector("[data-csv-import-modal]");
    const csvCloseButtons = csvModal ? csvModal.querySelectorAll("[data-csv-close]") : [];
    const csvFileInput = csvModal ? csvModal.querySelector("[data-csv-file]") : null;
    const csvStatus = csvModal ? csvModal.querySelector("[data-csv-status]") : null;
    const csvColumnsSection = csvModal ? csvModal.querySelector("[data-csv-columns]") : null;
    const csvBookIdSelect = csvModal ? csvModal.querySelector("[data-csv-book-id]") : null;
    const csvTagColumns = csvModal ? csvModal.querySelector("[data-csv-tag-columns]") : null;
    const csvValidateButton = csvModal ? csvModal.querySelector("[data-csv-validate]") : null;
    const csvImportSubmit = csvModal ? csvModal.querySelector("[data-csv-import-submit]") : null;
    const csvValidation = csvModal ? csvModal.querySelector("[data-csv-validation]") : null;
    const csvAllowedNamespaces = csvModal
      ? (csvModal.dataset.namespaces || "").split(",").map((entry) => entry.trim()).filter(Boolean)
      : [];

    let bulkBooks = [];
    let bulkIndex = 0;
    let bulkSelectedResultId = null;
    let bulkSelectedTags = [];
    let bulkStopped = false;
    let bulkRunning = false;
    let csvHeaders = [];
    let csvFile = null;
    let csvValidated = false;

    const bulkOpenModal = () => {
      bulkModal.removeAttribute("hidden");
      document.body.style.overflow = "hidden";
    };

    const bulkCloseModal = () => {
      bulkModal.setAttribute("hidden", "");
      document.body.style.overflow = "";
    };

    const csvOpenModal = () => {
      if (!csvModal) return;
      csvModal.removeAttribute("hidden");
      document.body.style.overflow = "hidden";
    };

    const csvCloseModal = () => {
      if (!csvModal) return;
      csvModal.setAttribute("hidden", "");
      document.body.style.overflow = "";
      if (csvFileInput) csvFileInput.value = "";
      csvResetMapping();
      csvSetStatus("Select a CSV file to begin.");
    };

    const csvSetStatus = (text) => {
      if (csvStatus) csvStatus.textContent = text;
    };

    const csvSetValidation = (text) => {
      if (csvValidation) csvValidation.textContent = text;
    };

    const csvParseLine = (line) => {
      const values = [];
      let current = "";
      let inQuotes = false;
      for (let i = 0; i < line.length; i += 1) {
        const char = line[i];
        if (char === '"') {
          if (inQuotes && line[i + 1] === '"') {
            current += '"';
            i += 1;
          } else {
            inQuotes = !inQuotes;
          }
          continue;
        }
        if (char === "," && !inQuotes) {
          values.push(current.trim());
          current = "";
          continue;
        }
        current += char;
      }
      values.push(current.trim());
      return values.filter((value) => value.length > 0);
    };

    const csvResetMapping = () => {
      csvHeaders = [];
      csvValidated = false;
      if (csvValidation) csvValidation.textContent = "";
      if (csvImportSubmit) csvImportSubmit.disabled = true;
      if (csvColumnsSection) csvColumnsSection.setAttribute("hidden", "");
      if (csvBookIdSelect) csvBookIdSelect.innerHTML = "";
      if (csvTagColumns) csvTagColumns.innerHTML = "";
    };

    const csvPopulateColumns = (headers) => {
      if (!csvBookIdSelect || !csvTagColumns || !csvColumnsSection) return;
      csvBookIdSelect.innerHTML = "";
      csvTagColumns.innerHTML = "";
      headers.forEach((header) => {
        const option = document.createElement("option");
        option.value = header;
        option.textContent = header;
        csvBookIdSelect.appendChild(option);

        const label = document.createElement("label");
        label.className = "list-item";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = header;
        const text = document.createElement("span");
        text.textContent = header;
        label.appendChild(checkbox);
        label.appendChild(text);
        csvTagColumns.appendChild(label);
      });
      const idIndex = headers.findIndex((header) => header.toLowerCase() === "id");
      if (idIndex >= 0) {
        csvBookIdSelect.value = headers[idIndex];
      }
      csvColumnsSection.removeAttribute("hidden");
    };

    const csvLoadHeaders = (file) => {
      csvResetMapping();
      if (!file) {
        csvSetStatus("Select a CSV file to begin.");
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        const text = String(reader.result || "");
        const firstLine = text.replace(/^\uFEFF/, "").split(/\r?\n/)[0] || "";
        const headers = csvParseLine(firstLine);
        if (!headers.length) {
          csvSetStatus("Unable to read CSV headers.");
          return;
        }
        csvHeaders = headers;
        csvPopulateColumns(headers);
        csvSetStatus("Select columns and validate the namespaces.");
      };
      reader.onerror = () => {
        csvSetStatus("Unable to read CSV file.");
      };
      reader.readAsText(file);
    };

    const csvGetSelectedTags = () => {
      if (!csvTagColumns) return [];
      const selected = Array.from(
        csvTagColumns.querySelectorAll("input[type='checkbox']:checked")
      ).map((input) => input.value);
      const bookIdColumn = csvBookIdSelect ? csvBookIdSelect.value : "";
      return selected.filter((value) => value !== bookIdColumn);
    };

    const csvValidateSelection = () => {
      if (!csvBookIdSelect) return false;
      const bookIdColumn = csvBookIdSelect.value;
      const selectedTags = csvGetSelectedTags();
      if (!bookIdColumn) {
        csvSetValidation("Select a book ID column.");
        return false;
      }
      if (!selectedTags.length) {
        csvSetValidation("Select at least one tag column.");
        return false;
      }
      const allowedLookup = new Set(csvAllowedNamespaces.map((entry) => entry.toLowerCase()));
      const invalid = selectedTags.filter(
        (tag) => allowedLookup.size && !allowedLookup.has(tag.toLowerCase())
      );
      csvValidated = true;
      csvSetValidation(
        invalid.length
          ? `Unknown namespaces: ${invalid.join(", ")}. Import will still proceed.`
          : "Looks good. Ready to import."
      );
      if (csvImportSubmit) csvImportSubmit.disabled = false;
      return true;
    };

    const bulkClearResults = () => {
      if (bulkResults) {
        bulkResults.innerHTML = "";
      }
      if (bulkTagsPreview) {
        bulkTagsPreview.innerHTML = "";
      }
      bulkSelectedResultId = null;
      bulkSelectedTags = [];
      if (bulkAddButton) bulkAddButton.disabled = true;
    };

    const bulkSetStatus = (text) => {
      if (bulkStatus) bulkStatus.textContent = text;
    };

    const bulkRenderCurrentTags = (tags) => {
      if (!bulkCurrentTags) return;
      bulkCurrentTags.innerHTML = "";
      if (!tags || tags.length === 0) {
        bulkCurrentTags.innerHTML = '<p class="note">No tags yet.</p>';
        return;
      }
      tags.forEach((tag) => {
        const pill = document.createElement("div");
        pill.className = "tag-pill";
        const label = document.createElement("span");
        label.textContent = tag;
        pill.appendChild(label);
        bulkCurrentTags.appendChild(pill);
      });
    };

    const bulkUpdateSelectedTags = () => {
      if (!bulkTagsPreview) {
        return;
      }
      const selected = Array.from(
        bulkTagsPreview.querySelectorAll("input[type='checkbox']:checked")
      ).map((input) => input.value);
      bulkSelectedTags = selected;
      if (bulkAddButton) bulkAddButton.disabled = bulkSelectedTags.length === 0;
    };

    const bulkRenderTags = (tags) => {
      if (!bulkTagsPreview) return;
      bulkTagsPreview.innerHTML = "";
      if (!tags.length) {
        bulkTagsPreview.innerHTML = '<p class="note">No tags returned.</p>';
        return;
      }
      tags.forEach((tag) => {
        const wrapper = document.createElement("label");
        wrapper.className = "tag-pill tag-pill-proposed";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = tag.tag_text;
        checkbox.checked = true;
        checkbox.addEventListener("change", bulkUpdateSelectedTags);
        const label = document.createElement("span");
        label.textContent = tag.tag_text;
        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        bulkTagsPreview.appendChild(wrapper);
      });
      bulkUpdateSelectedTags();
    };

    const bulkRenderResults = (results) => {
      if (!bulkResults) return;
      bulkResults.innerHTML = "";
      if (!results.length) {
        bulkSetStatus("No results found. Search again or skip.");
        return;
      }
      bulkSetStatus("Select a result to fetch tags.");
      results.forEach((result) => {
        const item = document.createElement("div");
        item.className = "list-item";
        item.dataset.resultId = result.result_id;

        const info = document.createElement("div");
        const title = document.createElement("strong");
        title.textContent = result.title || "Untitled";
        const author = document.createElement("div");
        author.className = "note";
        author.textContent = result.author || "Unknown author";
        info.appendChild(title);
        info.appendChild(author);

        const actions = document.createElement("div");
        const selectButton = document.createElement("button");
        selectButton.className = "btn btn-outline btn-small";
        selectButton.type = "button";
        selectButton.textContent = "Select";
        selectButton.addEventListener("click", () => {
          bulkSelectedResultId = result.result_id;
          const items = bulkResults.querySelectorAll(".list-item");
          items.forEach((node) => node.classList.remove("is-selected"));
          item.classList.add("is-selected");
          bulkSetStatus("Selected. Fetching tags...");
          bulkGetTags();
        });
        actions.appendChild(selectButton);

        item.appendChild(info);
        item.appendChild(actions);
        bulkResults.appendChild(item);
      });
    };

    const bulkShowBook = () => {
      if (bulkIndex >= bulkBooks.length) {
        bulkSetStatus("All books processed.");
        bulkClearResults();
        return;
      }
      const book = bulkBooks[bulkIndex];
      if (bulkTitle) bulkTitle.textContent = book.title || "Untitled";
      if (bulkAuthor) bulkAuthor.textContent = book.author || "Unknown author";
      bulkRenderCurrentTags(book.tags);
      bulkClearResults();
      bulkSetStatus("Search tags or skip this book.");
    };

    const bulkLoadBooks = async () => {
      bulkSetStatus("Loading books...");
      try {
        const response = await fetch("/bulk-actions/books");
        if (!response.ok) {
          throw new Error("Failed to load books.");
        }
        bulkBooks = await response.json();
        bulkIndex = 0;
        bulkStopped = false;
        if (!bulkBooks.length) {
          bulkSetStatus("No books found.");
          return;
        }
        bulkShowBook();
      } catch (error) {
        bulkSetStatus("Unable to load books.");
      }
    };

    const bulkSearchForBook = async (book) => {
      if (!book) return [];
      if (!book.title && !book.author) {
        bulkSetStatus("Missing title and author. Skip this book.");
        return [];
      }
      bulkSetStatus("Searching Google Books...");
      try {
        const params = new URLSearchParams();
        if (book.title) params.set("title", book.title);
        if (book.author) params.set("author", book.author);
        const response = await fetch(`/search?${params.toString()}`);
        if (!response.ok) {
          throw new Error("Search failed.");
        }
        const results = await response.json();
        bulkRenderResults(results);
        return results;
      } catch (error) {
        bulkSetStatus("Search failed. Try again or skip.");
        return [];
      }
    };

    const bulkGetTags = async () => {
      if (!bulkSelectedResultId) {
        bulkSetStatus("Select a result first.");
        return [];
      }
      bulkSetStatus("Loading tags...");
      try {
        const response = await fetch(`/search/${encodeURIComponent(bulkSelectedResultId)}/tags`);
        if (!response.ok) {
          throw new Error("Tags failed.");
        }
        const tags = await response.json();
        bulkRenderTags(tags);
        bulkSetStatus("Select tags, then add to book.");
        return tags;
      } catch (error) {
        bulkSetStatus("Unable to load tags.");
        return [];
      }
    };

    const bulkAddTagsToBook = async (bookId, tags) => {
      if (!tags.length) {
        bulkSetStatus("No tags to add.");
        return false;
      }
      bulkSetStatus("Adding tags...");
      const formData = new FormData();
      formData.set("tags", tags.join(", "));
      try {
        const response = await fetch(`/books/${bookId}/tags`, {
          method: "POST",
          body: formData,
        });
        if (!response.ok) {
          throw new Error("Add tags failed.");
        }
        return true;
      } catch (error) {
        bulkSetStatus("Unable to add tags.");
        return false;
      }
    };

    const bulkAddTags = async () => {
      const book = bulkBooks[bulkIndex];
      if (!book || !bulkSelectedTags.length) {
        bulkSetStatus("No tags to add.");
        return;
      }
      if (bulkAddButton) bulkAddButton.disabled = true;
      const added = await bulkAddTagsToBook(book.book_id, bulkSelectedTags);
      if (added) {
        bulkIndex += 1;
        bulkAdvanceLoop();
      }
    };

    const bulkAdvanceLoop = async () => {
      if (bulkRunning) return;
      bulkRunning = true;
      while (bulkIndex < bulkBooks.length) {
        if (bulkStopped) break;
        const book = bulkBooks[bulkIndex];
        if (book.tags && book.tags.length > 0) {
          bulkIndex += 1;
          continue;
        }
        bulkShowBook();
        const results = await bulkSearchForBook(book);
        if (bulkStopped) break;
        if (!results.length) {
          bulkSetStatus("No results found. Moving to next book...");
          bulkIndex += 1;
          continue;
        }
        bulkSetStatus("Select a result to fetch tags.");
        bulkRunning = false;
        return;
      }
      bulkRunning = false;
      if (!bulkStopped) {
        bulkSetStatus("Bulk tagging complete.");
        bulkClearResults();
        try {
          await fetch("/bulk-actions/complete", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ status: "completed", processed: bulkIndex, total: bulkBooks.length }),
          });
        } catch (error) {
          // Ignore logging errors for completion.
        }
      }
    };

    const bulkSkipBook = () => {
      bulkIndex += 1;
      bulkAdvanceLoop();
    };

    const bulkStop = () => {
      bulkStopped = true;
      bulkRunning = false;
      try {
        fetch("/bulk-actions/complete", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ status: "stopped", processed: bulkIndex, total: bulkBooks.length }),
        });
      } catch (error) {
        // Ignore logging errors for stop.
      }
      bulkCloseModal();
    };

    if (bulkTagsButton && bulkModal) {
      bulkTagsButton.addEventListener("click", () => {
        bulkOpenModal();
        bulkLoadBooks().then(() => {
          if (!bulkStopped) {
            bulkAdvanceLoop();
          }
        });
      });
    }

    if (bulkSearchButton) {
      bulkSearchButton.addEventListener("click", async () => {
        await bulkSearchForBook(bulkBooks[bulkIndex]);
      });
    }

    if (bulkSkipButton) {
      bulkSkipButton.addEventListener("click", bulkSkipBook);
    }

    if (bulkAddButton) {
      bulkAddButton.addEventListener("click", bulkAddTags);
    }

    if (bulkStopButton) {
      bulkStopButton.addEventListener("click", bulkStop);
    }

    bulkCloseButtons.forEach((button) => {
      button.addEventListener("click", bulkCloseModal);
    });

    if (cleanTagsButton && cleanTagsStatus) {
      cleanTagsButton.addEventListener("click", async () => {
        cleanTagsButton.disabled = true;
        cleanTagsStatus.textContent = "Cleaning...";
        try {
          const response = await fetch("/bulk-actions/cleanup-tags", { method: "POST" });
          if (!response.ok) {
            throw new Error("Cleanup failed.");
          }
          const result = await response.json();
          cleanTagsStatus.textContent = `Removed ${result.removed} unused tags.`;
        } catch (error) {
          cleanTagsStatus.textContent = "Cleanup failed. Check server logs.";
        } finally {
          cleanTagsButton.disabled = false;
        }
      });
    }

    if (clearTagsButton && clearTagsStatus) {
      clearTagsButton.addEventListener("click", async () => {
        const confirmed = window.confirm("Delete all tags and book-tag links?");
        if (!confirmed) return;
        clearTagsButton.disabled = true;
        clearTagsStatus.textContent = "Clearing...";
        try {
          const response = await fetch("/bulk-actions/clear-tags", { method: "POST" });
          if (!response.ok) {
            throw new Error("Clear failed.");
          }
          const result = await response.json();
          clearTagsStatus.textContent =
            `Removed ${result.removed_tags} tags and ${result.removed_links} links.`;
        } catch (error) {
          clearTagsStatus.textContent = "Clear failed. Check server logs.";
        } finally {
          clearTagsButton.disabled = false;
        }
      });
    }

    if (csvImportButton && csvModal) {
      csvImportButton.addEventListener("click", () => {
        csvOpenModal();
      });
    }

    if (csvFileInput) {
      csvFileInput.addEventListener("change", (event) => {
        const file = event.target.files ? event.target.files[0] : null;
        csvFile = file;
        csvLoadHeaders(file);
      });
    }

    if (csvValidateButton) {
      csvValidateButton.addEventListener("click", () => {
        csvValidateSelection();
      });
    }

    if (csvImportSubmit) {
      csvImportSubmit.addEventListener("click", async () => {
        if (!csvFile) {
          csvSetValidation("Select a CSV file first.");
          return;
        }
        if (!csvValidated && !csvValidateSelection()) {
          return;
        }
        const bookIdColumn = csvBookIdSelect ? csvBookIdSelect.value : "";
        const selectedTags = csvGetSelectedTags();
        const formData = new FormData();
        formData.set("file", csvFile);
        formData.set("book_id_column", bookIdColumn);
        formData.set("tag_columns", JSON.stringify(selectedTags));
        if (csvImportSubmit) csvImportSubmit.disabled = true;
        csvSetStatus("Importing tags...");
        csvSetValidation("");
        try {
          const response = await fetch("/bulk-actions/import-tags", {
            method: "POST",
            body: formData,
          });
          const result = await response.json();
          if (!response.ok) {
            throw new Error(result.detail || "Import failed.");
          }
          csvSetStatus("Import complete.");
          const warnings = result.unknown_namespaces && result.unknown_namespaces.length
            ? ` Unknown namespaces: ${result.unknown_namespaces.join(", ")}.`
            : "";
          csvSetValidation(
            `Books updated: ${result.books_updated}. Tags added: ${result.tags_added}.${warnings}`
          );
        } catch (error) {
          csvSetStatus("Import failed.");
          csvSetValidation(error.message || "Unable to import tags.");
        } finally {
          if (csvImportSubmit) csvImportSubmit.disabled = false;
        }
      });
    }

    csvCloseButtons.forEach((button) => {
      button.addEventListener("click", csvCloseModal);
    });
  </script>
{% endblock %}
